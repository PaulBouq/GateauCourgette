// --------------------------------------------------------
// BE Fiacre : Architecture SCADA Sécurisée
// Paul BOUQUET - Cédric DELAUNAY - Mathieu LOGARIO
// 15 Février 2019
// --------------------------------------------------------

const Nb_LC     : nat is 2
const SIZE_FIFO : nat is 5

type ID is union
  ADMIN
| GC_OWNER
| LC1_OWNER
| LC2_OWNER
| UNKNOWN
| GC
| Network
| LC1
| LC2
| ID_NUL
| ID_END
end union

type OPERATION is union
  READ
| WRITE
| ACK
| NACK
| OP_NUL
end union

type SIGNATURE is record
    CC_SIG  : ID,
    COM_SIG : ID,
    FU_SIG  : ID
end record

type REQUEST is record
    source      : ID,
    target      : ID,
    oper        : OPERATION,
    signature   : SIGNATURE,
    obj         : int,
	isAck 		: OPERATION
end record

type t_fifo is queue SIZE_FIFO of REQUEST


// --------------------------------------------------------
//              Déclaration des fonctions
// --------------------------------------------------------


//-----------------------------------------------------------------------
//    Fonction : Retourne true ou false selon les droits de l'Admin
//    Cette fonction implante les règles de droits d'accessibilite
//
//    Entree : requete de type REQUEST
//    Retour : true ou false selon les droits
//-----------------------------------------------------------------------
	
function hasRight_Admin (req : REQUEST) : bool is
begin
	case req.target of 
		GC -> 
			case req.oper of 
				READ  -> return true
			|	WRITE -> return true
			end
	|	LC1 -> 
			case req.oper of 
				READ  -> return true
			|	WRITE -> return true
			end
	|	LC2 -> 
			case req.oper of 
				READ  -> return true
			|	WRITE -> return true
			end
	end;
	return false
end


//-----------------------------------------------------------------------
//    Fonction : Retourne true ou false  selon les droits de GC_OWNER
//
//    Entree : requete de type REQUEST
//-----------------------------------------------------------------------
	
function hasRight_GC_OWNER (req : REQUEST) : bool is
begin
	case req.target of 
		GC -> 
			case req.oper of 
				READ  -> return true
			|	WRITE -> return true
			end
	|	LC1 -> 
			case req.oper of 
				READ  -> return true
			|	WRITE -> return false
			end
	|	LC2 -> 
			case req.oper of 
				READ  -> return true
			|	WRITE -> return false
			end
	end;
	return false
end



//-----------------------------------------------------------------------
//    Fonction : Retourne true ou false  selon les droits de LC1_OWNER
//
//    Entree : requete de type REQUEST
//-----------------------------------------------------------------------
	
function hasRight_LC1_OWNER (req : REQUEST) : bool is
begin
	case req.target of 
		GC -> 
			case req.oper of 
				READ  -> return false
			|	WRITE -> return false
			end
	|	LC1 -> 
			case req.oper of 
				READ  -> return true
			|	WRITE -> return true
			end
	|	LC2 -> 
			case req.oper of 
				READ  -> return false
			|	WRITE -> return false
			end
	end;
	return false
end


//-----------------------------------------------------------------------
//    Fonction : Retourne true ou false  selon les droits de LC2_OWNER
//
//    Entree : requete de type REQUEST
//-----------------------------------------------------------------------
	
function hasRight_LC2_OWNER (req : REQUEST) : bool is
begin
	case req.target of 
		GC -> 
			case req.oper of 
				READ  -> return false
			|	WRITE -> return false
			end
	|	LC1 -> 
			case req.oper of 
				READ  -> return false
			|	WRITE -> return false
			end
	|	LC2 -> 
			case req.oper of 
				READ  -> return true
			|	WRITE -> return true
			end
	end;
	return false
end


//-----------------------------------------------------------------------
//    Fonction : Retourne true ou false selon les droits de UNKNOWN
//
//    Entree : requete de type REQUEST
//-----------------------------------------------------------------------
	
function hasRight_Unknown (req : REQUEST) : bool is
begin
	case req.target of 
		GC -> 
			case req.oper of 
				READ  -> return false
			|	WRITE -> return false
			end
	|	LC1 -> 
			case req.oper of 
				READ  -> return false
			|	WRITE -> return false
			end
	|	LC2 -> 
			case req.oper of 
				READ  -> return false
			|	WRITE -> return false
			end
	end;
	return false
end

	
//-----------------------------------------------------------------------
//    Fonction : Retourne true ou false selon les droits
//
//    Entree : requete de type REQUEST
//-----------------------------------------------------------------------
	
function hasRight (req : REQUEST) : bool is
begin
	case req.source of 
		ADMIN     -> return (hasRight_Admin (req))
	|	GC_OWNER  -> return (hasRight_GC_OWNER (req))
	|	LC1_OWNER -> return (hasRight_LC1_OWNER (req))
	|	LC2_OWNER -> return (hasRight_LC2_OWNER (req))
	|	UNKNOWN   -> return (hasRight_Unknown (req))
	end;
	return false
end






// --------------------------------------------------------
//              Déclaration des process
// --------------------------------------------------------

// ######################################################
//                       SAP
// ######################################################
process SAP
	(&Ext_sap : read write t_fifo,
	 &Sap_ext : read write t_fifo,
	 &Int_sap :	read write t_fifo,
	 &Sap_int : read write t_fifo,
	 &CP_sap  : read write t_fifo,
	 &Sap_cp  : read write t_fifo,
	 &stage_id: ID)
is

states
	Idle,
	rec_from_ext,
	rec_from_int,
	rec_from_cp,
	send_to_ext,
	send_to_int,
	send_to_cp,
	sign

var
	req : REQUEST

init
	to Idle

from Idle
	if(empty Ext_sap and empty Int_sap and empty CP_sap) then 	//All fifo are empty
		loop
	elsif(empty Ext_sap and empty Int_sap) then									//CP fifo is not empty
		to rec_from_cp
	elsif(empty Ext_sap and empty CP_sap) then									//interior fifo not empty
		to rec_from_int
	elsif(empty Int_sap and empty CP_sap) then									//exterior fifo not empty
		to rec_from_ext
	end;

from rec_from_cp
	req := (first CP_sap);
	CP_sap := (dequeue CP_sap);
	if(req.isAck = ACK) then 					//2 possibilities : either the CP acknolegded or not
		to send_to_int
	else
		to send_to_ext
	end;

from rec_from_ext
	req := (first Ext_sap);
	Ext_sap := (dequeue Ext_sap);
	if(stage_id = GC) then
		to send_to_cp
	elsif(stage_id = Network) then
		if(req.signature.CC_SIG = GC) then
			to send_to_cp
		else
			send_to_ext
		end;
	elsif(stage_id = LC1) then
		if(req.signature.CC_SIG = GC and req.signature.COM_SIG = Network) then
			send_to_cp
		else
			send_to_ext
		end;
	end;

from rec_from_int
	req := (first Int_sap);
	Int_sap := (dequeue Int_sap);
	if(stage_id = GC) then
		if(req.signature.COM_SIG <> Network or req.signature.FU_SIG <> LC1) then
			req.isAck = NACK;
		end;
	elsif(stage_id = Network) then
		if(req.signature.FU_SIG <> LC1) then
			req.isAck = NACK;
		end;
	end;
	to send_to_ext

from send_to_cp
	if(full Sap_cp) then loop end;
	Sap_cp := enqueue(Sap_cp, req)
	to Idle

from send_to_int
	if(stage_id = GC) then
		req.signature.CC_SIG := GC;
	elsif(stage_id = Network) then
		req.signature.COM_SIG := Network;
	elsif(stage_id = LC1) then
		req.signature.FU_SIG := LC1;
	end;
	if(full Sap_int) then loop end;
	Sap_int := enqueue(Sap_int, req);
	to Idle;

from send_to_ext
	if(full Sap_ext) then loop end;
	Sap_ext := enqueue(Sap_ext, req)
	to Idle



// ######################################################
//                    CheckPoint
// ######################################################

	
process CheckPoint (&Sap_Cp : read write t_fifo,
            	    &Cp_Sap : read write t_fifo,
            	    &Cp_Fwl : read write t_fifo,
            	    &Fwl_Cp : read write t_fifo)


process Firewall (&CP_Fwl : read write t_fifo,
				  &Fwl_CP : read write t_fifo) is
states idle, sendResponse

var req : REQUEST,


init 
	to idle

from idle
	if (empty CP_Fwl) then loop end;
	req := first CP_Fwl;
	CP_Fwl := dequeue(CP_Fwl);
	to sendResponse

from sendResponse
	if (hasRight(req) = true) then 
		req.isAck := ACK;
	else 
		req.isAck := NACK;
	if (full Fwl_CP) then loop end;
	Fwl_CP := enqueue(Fwl_CP, req);
	end;
	to idle






function doCheck(req : REQUEST)

process SecurityManager(&outputSAP 	: t_fifo,
						&inputSAP 	: t_fifo,
						&outputAUTH : t_fifo,
						&inputAUTH 	: t_fifo) is
states
	idle, check, forward
	
var
	req : REQUEST
	
init
	req := REQ_NUL
	to idle

from idle
	if(empty inputSAP) then
		loop
	end
	
	req 	:= first inputSAP;
	input 	:= dequeue(inputSAP);
	to check

from check
	if(req.target = UNKNOWN) then
		req.isAck := NACK;
		
		if(full outputSAP) then
			loop
		
		else
			outputSAP := enqueue(outputSAP, req);
		
	else
		to forward

from forward
	outputAUTH := enqueue(outputAUTH, req);
	to idle
		



process LC



process PLC